## version

暴露当前所使用的 `Vue` 版本。

- 类型：`string`

使用：

```ts
import { version } from 'vue'
console.log(version)
```


## nextTick()

等待下一次 `DOM` 更新刷新的工具方法。注意：仔细研究会发现一些奇怪的现象。

- 类型：

```ts
function nextTick(callback?: () => void): Promise<void>
```

- 说明：

当 `Vue` 中更改响应式状态时，最终的 `DOM` 更新并不是同步生效的，而是由 `Vue` 将它们缓存在一个队列中，直到下一个“`tick`”才一起执行。这样是为了确保每个组件无论发生多少状态改变，都仅执行一次更新。

`nextTick()` 可以在状态改变后立即使用，以等待 `DOM` 更新完成。你可以传递一个回调函数作为参数，或者 `await` 返回的 `Promise`。

- 示例：

```ts
<script setup>
import { ref, nextTick } from 'vue'

const count = ref(0)

async function increment() {
  count.value++

  // DOM 还未更新
  console.log(document.getElementById('counter').textContent) // 0

  await nextTick()
  // DOM 此时已经更新
  console.log(document.getElementById('counter').textContent) // 1
}
</script>

<template>
  <button id="counter" @click="increment">{{ count }}</button>
</template>
```

- 源码位于[`packages/runtime-core/src/scheduler.ts`](https://github.com/vuejs/core/blob/main/packages/runtime-core/src/scheduler.ts)，这么少，但还是有东西的。

```ts
// 首先看到nextTick返回的是一个Promise
export function nextTick<T = void>(
  this: T,
  fn?: (this: T) => void
): Promise<void> {
  const p = currentFlushPromise || resolvedPromise
  // nextTick的回调函数是在Promise的then方法中执行的
  return fn ? p.then(this ? fn.bind(this) : fn) : p
}
```

在源码中有一个`currentFlushPromise`变量，并且这个变量是使用`let`声明的（说明会变）。进一步发现有两个地方用到这个变量：

`queueFlush`：将`currentFlushPromise`设置为一个`Promise`
`flushJobs`：将`currentFlushPromise`设置为`null`

## defineComponent()
## defineAsyncComponent()
## defineCustomElement()
