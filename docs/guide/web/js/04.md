## 函数

一个函数是 `JavaScript` 过程，一组执行任务或计算值的语句。要使用一个函数，你必须将其定义在你希望调用它的作用域内。

一个 `JavaScript` 函数用`function`关键字定义，后面跟着函数名和圆括号。

## 定义和調用函数

一个函数定义（也称为函数声明，或函数语句）由一系列的`function`关键字组成，依次为：

- 函数的名称。
- 函数参数列表，包围在括号中并由逗号分隔。
- 定义函数的 `JavaScript` 语句，用大括号`{}`括起来。

```js
function square(number) {
  return number * number;
}

square(4);// gets the value 16
```

函数`square`使用了一个参数，叫作`number`。这个函数只有一个语句，它说明该函数将函数的参数（即`number`）自乘后返回。函数的`return` 语句确定了函数的返回值：

- 函数表达式

虽然上面的函数声明在语法上是一个语句，但函数也可以由函数表达式创建。这样的函数可以是匿名的；它不必有一个名称。例如，函数square也可这样来定义：

```js
const square = function (number) {
  return number * number;
};
var x = square(4); // x gets the value 16
```

然而，函数表达式也可以提供函数名，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数：

```js
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3));
```

当将函数作为参数传递给另一个函数时，函数表达式很方便。下面的例子演示了一个叫`map`的函数如何被定义，而后使用一个表达式函数作为其第一个参数进行调用：

```js
function map(f, a) {
  let result = []; // 创建一个数组
  let i; // 声明一个值，用来循环
  for (i = 0; i != a.length; i++) result[i] = f(a[i]);
  return result;
}
```

下面是使用代码：

```js
function map(f, a) {
  let result = []; // 创建一个数组
  let i; // 声明一个值，用来循环
  for (i = 0; i != a.length; i++) result[i] = f(a[i]);
  return result;
}
const f = function (x) {
  return x * x * x;
};
let numbers = [0, 1, 2, 5, 10];
let cube = map(f, numbers);
console.log(cube);// 返回 [0, 1, 8, 125, 1000]。
```
在 `JavaScript` 中，可以根据条件来定义一个函数。比如下面的代码，当`num` 等于 `0` 的时候才会定义 `myFunc` ：

```js
var myFunc;
if (num == 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

当一个函数是一个对象的属性时，称之为方法。

函数一定要处于调用它们的域中，但是函数的声明可以被提升 (出现在调用语句之后)，如下例：

```js
console.log(square(5));
/* ... */
function square(n) {
  return n * n;
}
```

::: tip 备注： 
只有使用如上的语法形式（即 function funcName(){}）才可以。而下面的代码是无效的。就是说，函数提升仅适用于函数声明，而不适用于函数表达式。
:::

```js
console.log(square); // square is hoisted with an initial value undefined.
console.log(square(5)); // Uncaught TypeError: square is not a function
const square = function (n) {
  return n * n;
};
```

函数可以被递归，就是说函数可以调用其本身。例如，下面这个函数就是用递归计算阶乘：

```js
function factorial(n) {
  if (n == 0 || n == 1) return 1;
  else return n * factorial(n - 1);
}
```

## 函数作用域和函数堆栈

在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数。换言之，定义在全局域中的函数可以访问所有定义在全局域中的变量。

```js
// 下面的变量定义在全局作用域 (global scope) 中
var num1 = 20,
  num2 = 3,
  name = "Chamahk";

// 本函数定义在全局作用域
function multiply() {
  return num1 * num2;
}

multiply(); // 返回 60

// 嵌套函数的例子
function getScore() {
  var num1 = 2,
    num2 = 3;

  function add() {
    return name + " scored " + (num1 + num2);
  }

  return add();
}

getScore(); // 返回 "Chamahk scored 5"
```

- 递归

一个函数可以指向并调用自身。有三种方法可以达到这个目的：

1. 函数名
2. `arguments.callee`(`arguments.callee` 属性包含当前正在执行的函数。)
3. 作用域下的一个指向该函数的变量名

例如，思考一下如下的函数定义：

```js
var foo = function bar() {
  // statements go here
};
```

在这个函数体内，以下的语句是等价的：

- `bar()`
- `arguments.callee()` （译者注：`ES5` 禁止在严格模式下使用此属性）
- `foo()`

调用自身的函数我们称之为递归函数。在某种意义上说，递归近似于循环。两者都重复执行相同的代码，并且两者都需要一个终止条件（避免无限循环或者无限递归）。例如以下的循环：

```js
var x = 0;
while (x < 10) {
  // "x < 10" 是循环条件
  // do stuff
  x++;
}
```
可以被转化成一个递归函数和对其的调用：

```js
function loop(x) {
  if (x >= 10)
    // "x >= 10" 是退出条件（等同于 "!(x < 10)"）
    return;
  // 做些什么
  loop(x + 1); // 递归调用
}
loop(0);
```

不过，有些算法并不能简单的用迭代来实现。例如，获取树结构中所有的节点时，使用递归实现要容易得多：

```js
function walkTree(node) {
  if (node == null) return;
  // do something with node
  for (var i = 0; i < node.childNodes.length; i++) {
    walkTree(node.childNodes[i]);
  }
}
```

跟`loop`函数相比，这里每个递归调用都产生了更多的递归。

将递归算法转换为非递归算法是可能的，不过逻辑上通常会更加复杂，而且需要使用堆栈。事实上，递归函数就使用了堆栈：函数堆栈。

这种类似堆栈的行为可以在下例中看到：

```js
function foo(i) {
  if (i < 0) return;
  console.log("begin:" + i);
  foo(i - 1);
  console.log("end:" + i);
}
foo(3);

// 输出：

// begin:3
// begin:2
// begin:1
// begin:0
// end:0
// end:1
// end:2
// end:3
```

## 嵌套函数和闭包

你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数）。

可以总结如下：

- 内部函数只可以在外部函数中访问。
- 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。

```js
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
a = addSquares(2, 3); // returns 13
b = addSquares(3, 4); // returns 25
c = addSquares(4, 5); // returns 41
```

由于内部函数形成了闭包，因此你可以调用外部函数并为外部函数和内部函数指定参数：

```js
function outside(x) {
  function inside(y) {
    return x + y;
  }
  return inside;
}
fn_inside = outside(3); // 可以这样想：给一个函数，使它的值加 3
result = fn_inside(5); // returns 8

result1 = outside(3)(5); // returns 8
```

- 保存变量

注意到上例中 `inside` 被返回时 `x` 是怎么被保留下来的。一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包。只有当返回的 `inside` 没有再被引用时，内存才会被释放。

这与在其他对象中存储引用没什么不同，但是通常不太明显，因为并不能直接设置引用，也不能检查它们。

函数可以被多层嵌套。例如，函数 `A` 可以包含函数 `B`，函数 `B` 可以再包含函数 `C`。`B` 和 `C` 都形成了闭包，所以 `B` 可以访问 `A`，`C` 可以访问 `B` 和 `A`。因此，闭包可以包含多个作用域；他们递归式的包含了所有包含它的函数作用域。这个称之为作用域链。

```js
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // logs 6 (1 + 2 + 3)
```

在这个例子里面，`C` 可以访问 `B` 的 `y` 和 `A` 的 `x`。这是因为：

1. `B` 形成了一个包含 `A` 的闭包，`B` 可以访问 `A` 的参数和变量
2. `C` 形成了一个包含 `B` 的闭包
3. `B` 包含 `A`，所以 `C` 也包含 `A`，`C` 可以访问 `B` 和 `A` 的参数和变量。换言之，`C` 用这个顺序链接了 `B` 和 `A` 的作用域

反过来却不是这样。`A` 不能访问 `C`，因为 `A` 看不到 `B` 中的参数和变量，`C` 是 `B` 中的一个变量，所以 `C` 是 `B` 私有的。

- 命名冲突

当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。

例子：

```js
function outside() {
  var x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

outside()(10); // returns 20 instead of 10
```

命名冲突发生在`return x`上，`inside`的参数`x`和`outside`变量`x`发生了冲突。这里的作用链域是`{inside, outside, 全局对象}`。因此`inside`的`x`具有最高优先权，返回了 `20（inside的x）`而不是 `10（outside的x）`。

内嵌函数的内嵌变量就像内嵌函数的保险柜。它们会为内嵌函数保留“稳定”——而又安全——的数据参与运行。而这些内嵌函数甚至不会被分配给一个变量，或者不必一定要有名字。

```js
var getCode = (function () {
  var secureCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify...

  return function () {
    return secureCode;
  };
})();

getCode(); // Returns the secret code
```

::: tip 备注： 
尽管有上述优点，使用闭包时仍然要小心避免一些陷阱。如果一个闭包的函数定义了一个和外部函数的某个变量名称相同的变量，那么这个闭包将无法引用外部函数的这个变量。
```js
var createPet = function (name) {
  // Outer function defines a variable called "name"
  return {
    setName: function (name) {
      // Enclosed function also defines a variable called "name"
      name = name; // ??? How do we access the "name" defined by the outer function ???
    },
  };
};
```
:::

## arguments 对象

函数的实际参数会被保存在一个类似数组的 `arguments` 对象中。在函数内，你可以按如下方式找出传入的参数：