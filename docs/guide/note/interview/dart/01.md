## Dart 是不是單線程？如何運行的？

`Dart` 是单线程模型

運行流程大致如下：

1. 先开启 `app` 执行入口函数 `main()`,执行完成之后，消息机制启动
2. 会按照先进先出的顺序逐个执行微任务队列中的任务`microtask`
3. 事件任务 `eventtask` 执行完毕后便会退出
4. 但是，在事件任务执行的过程中也可以插入新的微任务和事件任务
5. 在这种情况下，整个线程的执行过程便是一直在循环，不会退出

在事件循环中，当某个任务发生异常并没有被捕获时，程序并不会退出，而直接导致的结果是当前任务的后续代码就不会被执行了，也就是说一个任务中的异常是不会影响其它任务执行的。

Dart 中事件的执行顺序：`Main` > `MicroTask` > `EventQueue`

在 Dart 中，所有的外部事件任务都在事件队列中，如 IO、计时器、点击、以及绘制事件等，而微任务通常来源于 Dart 内部，并且微任务非常少

## main 入口函数会被调用几次

先开启 app 执行入口函数 main()

- 入口函数 执行的次数取决于 引擎的启动次数，每启动一次引擎，执行一次入口函数 。
- 引擎的入口函数是可以指定的，默认是 main。

## Flutter 多平台原理。

- Skia 绘制，实现跨平台应用层渲染一致性
- Method Channel 机制

Flutter 定义了三种不同类型的 Channel

- BasicMessageChannel：用于传递字符串和半结构化的信息。
- MethodChannel：用于传递方法调用（method invocation）。
- EventChannel: 用于数据流（event streams）的通信。

:::danger
Method Channel 是非线程安全的。原生代码在处理方法调用请求时，如果涉及到异步或非主线程切换，需要确保回调过程是在原生系统的 UI 线程（也就是 Android 和 iOS 的主线程）中执行的，否则应用可能会出现奇怪的 Bug，甚至是 Crash。
:::

## isolate

Dart 中的 isolate 是一个单独的、独立的执行单元，它与主线程并行运行。 Isolates 允许您在 Dart 中执行并发编程。

每个 isolate 都有自己的堆内存，这意味着它不与主线程或其他 isolate 共享内存。

每个 isolate 都有自己的堆内存，这意味着它不与主线程或其他 isolate 共享内存。

Isolates 通过消息传递相互通信，通常使用 SendPort 和 ReceivePort。 当你想在 Isolates 之间发送数据时，你需要确保数据是原始数据（例如，数字、布尔值、字符串），或者是可以序列化和反序列化的数据，因为数据是值传递，而非引用传递。

以下是 Dart 中 isolates 如何工作的分步说明：

1. 创建：使用 Isolate.spawn() 函数创建一个新的 isolate，将顶层函数或静态方法作为入口点传递给它；同时也要传递一个初始消息参数（通常是 SendPort），以在 isolates 之间建立通信。

2. 消息传递：由于隔离不共享内存，因此它们使用消息传递进行通信。 要发送和接收消息，您可以使用 SendPort 和 ReceivePort 对象。 SendPort 用于将消息发送到接收隔离区，而 ReceivePort 用于监听传入消息。 消息是值传递而非引用传递，这意味着发送数据的拷贝，而不是对原始数据的引用。

3. 执行：每个 isolate 都有自己的事件循环和事件队列。 当一个 isolate 收到一条消息时，该消息被添加到事件队列中。 事件循环一条一条地处理队列中的消息，执行关联的任务或函数。 isolate 持续处理消息，直到事件队列为空或 isolate 终止。

4. 终止：isolate 可以通过编程方式终止，也可以在它完成其事件队列中的所有任务时终止。 要以编程方式终止 isolate，您可以使用 Isolate.kill() 方法或向 isolate 发送特定消息，标定它应该自行终止。
